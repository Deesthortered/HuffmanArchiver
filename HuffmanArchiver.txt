Архиватор Хафмана

Алгоритм Хафманна в общем виде:

Кодер
1. Создаем авл дерево. Его поля - код, частота, высота дерева, динамический битсет.
2. Считываем файл кусками указаной в условии длины, и эти куски включаем в дерево.
   В итоге получим дерево со всеми возможными кодами, их частотами и высотой.
   Битсет пока не трогаем. Функция вставки возвращает 1, если елемент уже существует в дереве, и 0 если нет. С помощью этого считаем сколько у нас всего разных букв.
3. У нас есть структура узла дерева хаффмана: код, частота, ссылки на дочерние узлы.
   Создаем очередь с приоритетатами. Она будет хранить узлы дерева хафманна, который будет брать данные из авл дерева.
   Таким образом мы построили дерево хаффмана и опустошили очередь.
4. У нас осталось авл дерево и дерево Хафманна.
   Увы, высота авл дерева нам не нужна (но ее убирать не придется она нужна внутри), но нам нужно узнать высоту дерева
   хаффманна, что бы знать максимальную длину кода хафманна.
   Создаем рекурсивную функцию, которая обойдет все дерево хафманна, узнает код для каждого старого кода и таким образом 
   по пути заполнит битсеты в авл дереве. И узнаем заодно максимальную длину кода хафманна.
   В итоге, все битсеты в авл дереве заполнены, длина есть, можем удалить дерево хаффмана.
5. Далее нужно записать новый файл.
   Для этого нужно вписать таблицу в файл для декодирования
   Сначала вписать: количество букв(ull), вес одного куска-оригинала(size_t), количество байт для кода максимальной длины (сhar)
                    а дальше вписать структуры, которые хранят - (буква (занимает вес одного-куска оригинала выше), длина в битах кода (char), код)
6. После этого создаем рабочий битсет длиною 2*max(8 бит, длина максимального кода хафманна)
   Создаем файловый поток - чтения нашего файла, записи еще остался с предыдущего шага.
   А дальше в цикле пока не прочтем весь наш файл -
     считали кусок, впихнули в бисет его код хаффмана и пока он не заполнится на байт.
     Как только заполнится, то этот байт вписать в новый файл.
   Когда главный файл закончится - вписать последний байт.

Декодер
1. Открыть файл на чтение и по порядку считать: количество букв(ull), вес одного куска-оригинала(size_t), количество байт для кода максимальной длины (сhar)
   после этого считываем структуры, которые хранят - (буква (занимает вес одного-куска оригинала выше), длина в битах кода (char), код).
   Эти структуры заносим в авл дерево, но уже по коду, а не по оригиналу.
   В итоге авл дерево заполнено, есть оригинал, его код в битсете, а количества нет и пофиг, оно не надо.
   Потом создаем рабочий битсет размером 2*max(8 бит, длина максимального кода хафманна)
   Дальше считываем байт в цикле, а там вложеный цикл, который проганяет биты

			if (this->bit_size != obj.bit_size) return false;
			size_t i1 = this->bit_size >> 3;
			for (register size_t i = 0; i < i1; i++)
				if (this->arr[i] != obj.arr[i]) return false;
			size_t i2 = this->bit_size - ((this->bit_size >> 3) << 3);
			if (!i2) return true;
			char c = (-128 >> (i2 - 1));
			return (this->arr[i1] & c) == (obj.arr[i1] & c);

